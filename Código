# Projeto Arduino Master–Slave

Este repositório contém o código para o Arduino Mega (Master) e três Arduinos Uno (Slaves), exibindo imagens BMP num display TFT via SD.

---

## Master (Mega)

```cpp
```cpp
const int numCores = 8;
const int numSlaves = 3;

// Cores fixas: 1 = vermelho(cobra), 2 = rosa(porco), 3 = laranja(tigre), 4 = azul(baleia), 
// 5 = verde(sapo), 6 = preto(gato), 7 = branco(ovelha), 8 = amarelo(pinto)
const int coresFixas[numCores] = {1, 2, 3, 4, 5, 6, 7, 8};

int coresSelecionadas[numSlaves];
int corCorreta = 0;
bool aguardandoAcerto = false;
int tentativasRestantes = 0;

// === Mapeamento dos botões (fixo) ===
const int botoes[numCores] = {2, 3, 4, 5, 6, 7, 8, 9};

// === Mapeamento das letras ===
// b = baleia(4), c = cobra(1), g = gato(6), o = ovelha(7),
// p = pinto(8), r = porco(2), s = sapo(5), t = tigre(3)
const char letras[numCores] = {'c', 'r', 't', 'b', 's', 'g', 'o', 'p'};

void embaralharCores(int vetor[], int tamanho) {
  for (int i = tamanho - 1; i > 0; i--) {
    int j = random(i + 1);
    int temp = vetor[i];
    vetor[i] = vetor[j];
    vetor[j] = temp;
  }
}

void setup() {
  Serial.begin(9600);
  Serial1.begin(9600);
  Serial2.begin(9600);
  Serial3.begin(9600);

  for (int i = 0; i < numCores; i++) {
    pinMode(botoes[i], INPUT_PULLUP);
  }

  randomSeed(analogRead(0));
}

void loop() {
  if (!aguardandoAcerto) {
    // Copia as cores fixas para um vetor temporário
    int coresTemp[numCores];
    memcpy(coresTemp, coresFixas, sizeof(coresTemp));

    // Embaralha e seleciona as cores dos slaves
    embaralharCores(coresTemp, numCores);
    for (int i = 0; i < numSlaves; i++) {
      coresSelecionadas[i] = coresTemp[i];
    }

    // Escolhe qual cor é a correta
    int indiceCorreta = random(numSlaves);
    corCorreta = coresSelecionadas[indiceCorreta];

    // Envia o comando para cada slave
    for (int i = 0; i < numSlaves; i++) {
      int cor = coresSelecionadas[i];
      char letra = letras[cor - 1];
      if (i == 0)      Serial1.write(letra);
      else if (i == 1) Serial2.write(letra);
      else if (i == 2) Serial3.write(letra);
    }

    tentativasRestantes = 2;
    aguardandoAcerto = true;
    Serial.print("Cor correta: ");
    Serial.println(corCorreta);
    Serial.println("Aguardando tentativa...");
  }

  // Verifica tentativas de acerto
  if (aguardandoAcerto) {
    for (int i = 0; i < numCores; i++) {
      if (digitalRead(botoes[i]) == LOW) {
        delay(200);  // debounce
        int tentativa = i + 1;
        Serial.print("Tentativa: ");
        Serial.println(tentativa);

        if (tentativa == corCorreta) {
          Serial.println("Acertou!");
          Serial1.write(0);
          Serial2.write(0);
          Serial3.write(0);
          aguardandoAcerto = false;
          delay(2000);
        } else {
          tentativasRestantes--;
          if (tentativasRestantes > 0) {
            Serial.print("Errou! Restam ");
            Serial.print(tentativasRestantes);
            Serial.println(" tentativas.");
          } else {
            Serial.println("Fim de tentativas. Reiniciando...");
            Serial1.write(0);
            Serial2.write(0);
            Serial3.write(0);
            aguardandoAcerto = false;
            delay(2000);
          }
        }
        // Espera o botão ser solto
        while (digitalRead(botoes[i]) == LOW) delay(200);
      }
    }
  }
}






---

## Slave (Uno)

```cpp
#include <SPI.h>
#include <SD.h>
#include <Adafruit_GFX.h>
#include <MCUFRIEND_kbv.h>
MCUFRIEND_kbv tft;

#if defined(ESP32)
#define SD_CS     5
#else
#define SD_CS     10
#endif

#define PALETTEDEPTH   0

// Arquivos BMP para cada comando
const char* animalFiles[] = {
  "/gato.bmp",    // g
  "/baleia.bmp",  // b
  "/cobra.bmp",   // c
  "/ovelha.bmp",  // o
  "/pinto.bmp",   // p
  "/porco.bmp",   // r
  "/sapo.bmp",    // s
  "/tigre.bmp"    // t
};
const char comandos[] = {'g','b','c','o','p','r','s','t'};
const int animalCount = sizeof(animalFiles) / sizeof(animalFiles[0]);

void setup() {
  Serial.begin(9600);
  Serial.println("===== COMANDOS =====");
  Serial.println("g=Gato b=Baleia c=Cobra o=Ovelha");
  Serial.println("p=Pinto r=Porco s=Sapo t=Tigre x=Limpar");
  Serial.println("====================");

  uint16_t ID = tft.readID();
  if (ID == 0x0D3D3) ID = 0x9481;
  tft.begin(ID);
  tft.fillScreen(0x0000);

  if (!SD.begin(SD_CS)) {
    Serial.println("Falha no SD!");
    while (1);
  }
}

void loop() {
  if (Serial.available()) {
    char cmd = Serial.read();
    if (cmd == 'x') {
      tft.fillScreen(0x0000);
      Serial.println("Tela limpa.");
      return;
    }
    for (int i = 0; i < animalCount; i++) {
      if (cmd == comandos[i]) {
        Serial.print("Exibindo ");
        Serial.println(animalFiles[i]);
        tft.fillScreen(0x0000);
        showBMP((char*)animalFiles[i], 5, 5);
        break;
      }
    }
  }
}

// === Funções auxiliares ===
#define BMPIMAGEOFFSET 54
#define BUFFPIXEL 20

uint16_t read16(File& f) {
  uint16_t r; f.read((uint8_t*)&r, sizeof(r)); return r;
}

uint32_t read32(File& f) {
  uint32_t r; f.read((uint8_t*)&r, sizeof(r)); return r;
}

uint8_t showBMP(char *nm, int x, int y) {
  File bmpFile = SD.open(nm);
  if (!bmpFile) return 2;
  if (read16(bmpFile) != 0x4D42) return 2;
  uint32_t bmpImageoffset = read32(bmpFile);
  int bmpWidth  = read32(bmpFile);
  int bmpHeight = read32(bmpFile);
  read16(bmpFile); // planes
  uint16_t bmpDepth = read16(bmpFile);
  uint32_t pos = read32(bmpFile);
  bool flip = true;
  if (bmpHeight < 0) { bmpHeight = -bmpHeight; flip = false; }
  
  uint32_t rowSize = (bmpWidth * bmpDepth/8 + 3) & ~3;
  tft.setAddrWindow(x, y, x + bmpWidth - 1, y + bmpHeight - 1);
  
  uint8_t sdbuf[3*BUFFPIXEL];
  uint16_t lcdbuf[BUFFPIXEL];
  for (int row=0; row<bmpHeight; row++) {
    uint32_t rowPos = bmpImageoffset + (flip
      ? (bmpHeight-1-row)*rowSize
      : row*rowSize);
    if (bmpFile.position() != rowPos) {
      bmpFile.seek(rowPos);
    }
    for (int col=0; col<bmpWidth; col+=BUFFPIXEL) {
      int toRead = min(BUFFPIXEL, bmpWidth-col);
      bmpFile.read(sdbuf, 3*toRead);
      for (int i=0; i<toRead; i++) {
        uint8_t b=sdbuf[3*i], g=sdbuf[3*i+1], r=sdbuf[3*i+2];
        lcdbuf[i] = tft.color565(r,g,b);
      }
      tft.pushColors(lcdbuf, toRead, col==0 && row==0);
    }
  }
  bmpFile.close();
  return 0;
}

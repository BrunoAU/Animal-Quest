üü¶ C√≥digo (Master-Mega)

const int numCores = 8;
const int numSlaves = 3;

int cores[numCores] = {1,2,3,4,5,6,7,8};
int coresSelecionadas[numSlaves];
int corCorreta = 0;
bool aguardandoAcerto = false;
int tentativasRestantes = 0;

// === Mapeamento dos bot√µes ===
const int botoes[numCores] = {2, 3, 4, 5, 6, 7, 8, 9};  
const char letras[numCores] = {'p','v','a','b','c','d','e','f'};  

void embaralharCores() {
  for (int i = numCores - 1; i > 0; i--) {
    int j = random(i + 1);
    int temp = cores[i];
    cores[i] = cores[j];
    cores[j] = temp;
  }
}

void setup() {
  Serial.begin(9600);     
  Serial1.begin(9600);    
  Serial2.begin(9600);    
  Serial3.begin(9600);    

  for(int i = 0; i < numCores; i++) {
    pinMode(botoes[i], INPUT_PULLUP);  
  }

  randomSeed(analogRead(0));
}

void loop() {
  if (!aguardandoAcerto) {
    embaralharCores();
    for (int i = 0; i < numSlaves; i++) {
      coresSelecionadas[i] = cores[i];
    }

    int indiceCorreta = random(numSlaves);
    corCorreta = coresSelecionadas[indiceCorreta];

    // Envia para os slaves
    Serial1.write(coresSelecionadas[0]);
    Serial2.write(coresSelecionadas[1]);
    Serial3.write(coresSelecionadas[2]);

    Serial.println("Cores enviadas:");
    for (int i = 0; i < numSlaves; i++) {
      Serial.print("Slave ");
      Serial.print(i + 1);
      Serial.print(": Cor ");
      Serial.println(coresSelecionadas[i]);
    }

    Serial.print("Cor correta: ");
    Serial.println(corCorreta);

    // Envia para o Python o som
    Serial.print("COR:");
    Serial.println(corCorreta);

    tentativasRestantes = 2;
    aguardandoAcerto = true;

    Serial.println("Aguardando tentativa via bot√µes...");
  }

  if (aguardandoAcerto) {
    for(int i = 0; i < numCores; i++) {
      if (digitalRead(botoes[i]) == LOW) {  
        delay(200);  

        char letra = letras[i];
        int tentativa = cores[i];  

        Serial.print("Bot√£o pressionado: ");
        Serial.print(letra);
        Serial.print(" ‚Üí Tentativa: ");
        Serial.println(tentativa);

        if (tentativa == corCorreta) {
          Serial.println("Parab√©ns, voc√™ acertou! :)");

          Serial1.write(0);
          Serial1.write('O');
          Serial2.write(0);
          Serial2.write('O');
          Serial3.write(0);
          Serial3.write('O');

          aguardandoAcerto = false;
          delay(2000);
        } else {
          tentativasRestantes--;
          if (tentativasRestantes > 0) {
            Serial.print("N√£o foi dessa vez! Restam ");
            Serial.print(tentativasRestantes);
            Serial.println(" tentativa(s).");

            // üî• Repete o som ap√≥s erro
            Serial.print("COR:");
            Serial.println(corCorreta);
          } else {
            Serial.println("Que pena! Suas tentativas acabaram. Reiniciando o jogo...");

            Serial1.write(0);
            Serial2.write(0);
            Serial3.write(0);

            aguardandoAcerto = false;
            delay(2000);
          }
        }

        // Debounce ‚Äî espera o bot√£o ser solto
        while(digitalRead(botoes[i]) == LOW) { delay(10); }
      }
    }
  }
}




C√≥digo (Slave-Unos)

#include <Adafruit_GFX.h>
#include <MCUFRIEND_kbv.h>
#include <SPI.h>
#include <SD.h>

// === Display e SD ===
#define SD_CS 10  // Pino do cart√£o SD no display

MCUFRIEND_kbv tft;
int16_t wid, ht;

int corRecebida = 0;
bool travado = false;

void setup() {
  Serial.begin(9600);    // Comunica√ß√£o com o Arduino Mega

  // Inicializa o display
  uint16_t ID = tft.readID();
  tft.begin(ID);
  tft.setRotation(1);
  tft.fillScreen(0x0000);  // Tela preta

  wid = tft.width();
  ht = tft.height();

  // Inicializa o cart√£o SD
  if (!SD.begin(SD_CS)) {
    tft.setCursor(10, 10);
    tft.setTextColor(0xF800); // Vermelho
    tft.setTextSize(2);
    tft.println("Falha no SD!");
    while (1);
  }
}

void loop() {
  if (Serial.available()) {
    char dado = Serial.read();

    if (dado == '0') {
      travado = false;
      tft.fillScreen(0x0000);  // Limpa a tela
    } else if (dado == 'O') {
      reforcoPositivo();
    } else if (!travado) {
      corRecebida = dado;
      travado = true;

      switch (corRecebida) {
        case 'b': mostrarImagem("/baleia.bmp"); break;
        case 'c': mostrarImagem("/cobra.bmp"); break;
        case 'g': mostrarImagem("/gato.bmp"); break;
        case 'o': mostrarImagem("/ovelha.bmp"); break;
        case 'p': mostrarImagem("/pinto.bmp"); break;
        case 'r': mostrarImagem("/porco.bmp"); break;
        case 's': mostrarImagem("/sapo.bmp"); break;
        case 't': mostrarImagem("/tigre.bmp"); break;
        default:
          tft.fillScreen(0x0000);
          break;
      }
    }
  }
}

void mostrarImagem(const char *nomeArquivo) {
  tft.fillScreen(0x0000);

  File bmpFile = SD.open(nomeArquivo);
  if (!bmpFile) {
    tft.setCursor(10, 10);
    tft.setTextColor(0xF800); // Vermelho
    tft.setTextSize(2);
    tft.println("Erro imagem");
    return;
  }

  bmpDraw(nomeArquivo, 0, 0);
  bmpFile.close();
}

void reforcoPositivo() {
  tft.fillScreen(0xFFFF); // Tela branca
  tft.setTextColor(0x07E0); // Verde
  tft.setTextSize(3);
  tft.setCursor(30, ht / 2);
  tft.println("PARABENS!");
  delay(2000);
  tft.fillScreen(0x0000);
}

// === Fun√ß√£o para desenhar BMP ===
#define BUFFPIXEL 20

void bmpDraw(const char *filename, int x, int y) {
  File bmpFile;
  int bmpWidth, bmpHeight;
  uint8_t bmpDepth;
  uint32_t bmpImageoffset;
  uint32_t rowSize;
  uint8_t sdbuffer[3 * BUFFPIXEL];
  uint16_t lcdbuffer[BUFFPIXEL];
  uint8_t buffidx = sizeof(sdbuffer);
  boolean goodBmp = false;
  boolean flip = true;
  int w, h, row, col;
  uint8_t r, g, b;
  uint32_t pos = 0;

  bmpFile = SD.open(filename);
  if (!bmpFile) {
    Serial.println("Arquivo n√£o encontrado");
    return;
  }

  if (read16(bmpFile) == 0x4D42) {
    (void)read32(bmpFile);
    (void)read32(bmpFile);
    bmpImageoffset = read32(bmpFile);
    (void)read32(bmpFile);
    bmpWidth = read32(bmpFile);
    bmpHeight = read32(bmpFile);
    if (read16(bmpFile) == 1) {
      bmpDepth = read16(bmpFile);
      if ((bmpDepth == 24) && (read32(bmpFile) == 0)) {
        goodBmp = true;
        rowSize = (bmpWidth * 3 + 3) & ~3;

        if (bmpHeight < 0) {
          bmpHeight = -bmpHeight;
          flip = false;
        }

        w = bmpWidth;
        h = bmpHeight;
        if ((x + w - 1) >= tft.width())  w = tft.width() - x;
        if ((y + h - 1) >= tft.height()) h = tft.height() - y;

        tft.setAddrWindow(x, y, x + w - 1, y + h - 1);

        for (row = 0; row < h; row++) {
          if (flip) pos = bmpImageoffset + (bmpHeight - 1 - row) * rowSize;
          else pos = bmpImageoffset + row * rowSize;

          if (bmpFile.position() != pos) {
            bmpFile.seek(pos);
            buffidx = sizeof(sdbuffer);
          }

          for (col = 0; col < w; col++) {
            if (buffidx >= sizeof(sdbuffer)) {
              bmpFile.read(sdbuffer, sizeof(sdbuffer));
              buffidx = 0;
            }

            b = sdbuffer[buffidx++];
            g = sdbuffer[buffidx++];
            r = sdbuffer[buffidx++];

            lcdbuffer[col] = tft.color565(r, g, b);
          }
          tft.pushColors(lcdbuffer, w, 1);
        }
      }
    }
  }
  bmpFile.close();
}

uint16_t read16(File &f) {
  uint16_t result;
  ((uint8_t *)&result)[0] = f.read();
  ((uint8_t *)&result)[1] = f.read();
  return result;
}

uint32_t read32(File &f) {
  uint32_t result;
  ((uint8_t *)&result)[0] = f.read();
  ((uint8_t *)&result)[1] = f.read();
  ((uint8_t *)&result)[2] = f.read();
  ((uint8_t *)&result)[3] = f.read();
  return result;
}
